#!/bin/bash
TMISS_BIN=transmission-remote-2.04-1
ROWSINWINDOW=52
let ROWSINWINDOW-=3

#TSFILE_BIG=/tmp/.tsfilebig
#TSFILE_LIT=/tmp/.tsfilelit
#[ -f "$TSFILE_BIG" ] || echo -n 6367 > "$TSFILE_BIG"
#[ -f "$TSFILE_LIT" ] || echo -n  802 > "$TSFILE_LIT"
TSBIG=5361 #$(cat "$TSFILE_BIG")
TSLIT=999 #$(cat "$TSFILE_LIT")

[ "${1^^}" == "LOOP" ] && {
	shift
	while [ 1 ]; do
		sleep 0
		$0 "$@" | {
			L=0
			IFSB=$IFS
			IFS='
'
			while read LINE; do
				let L++
				echo -e "$LINE"
			done
			IFS=$IFSB
			let L=$ROWSINWINDOW-$L
			while let L--; do
				echo
			done
		}
	done
	exit
}

[ "${1^^}" == "NAME" ] && {
	N=$2
	shift 2
	$0 'n("'"${N}"'")' "$@"
	exit
}

[ "$1" == "NORMAL" ] && {
	$0 ALL BEHAVE
	$TMISS_BIN --encryption-required --no-global-seedratio
	exit
}

[ "$1" == "POLICY" ] && {
	$0 '!RUNNING && HUNG && DONE' SUPERSEED				# don't leave ppl hanging!
	$0 ONLYSEEDISPROBSME SUPERSEED							# don't leave ppl hanging!
	$0 'ALMOSTDONE && !HUNG' HURRY							# get it over with and seed
	$0 'DONE && !HUNG && !ONLYSEEDISPROBSME' BEHAVE 1>/dev/null	# ^ when this is done
	$0 ALMOSTOFFTHEHOOK GETOFF									# torrent dont need me, just want my 1 ratio
	$0 'RUNNING && OFFTHEHOOK' STOP							# good work torrent, now hit the showers
	exit
}

COLRMS=33

unhash() {
	KEY=${1^^}
	eval echo '${hash'"$KEY"'#hash}'
}

enhash() {
	KEY=$1
	shift
	[ "$1" == "cc" ] && { #concat previous values
		VAL=""
		while shift; do
			VAL=${VAL}' '$( unhash "${1}" )
		done
	} || VAL="$*"
	eval hash${KEY}=\$\{VAL\}
}

ckhash() {
	return $( eval '[ ! -z "${hash'${1}'}" ]' )
}

enhash START       --start
enhash STOP        --stop
enhash NORMAL      --priority-normal all
enhash HIGH        --priority-high   all
enhash LOW         --priority-low    all
enhash HONOR          --honor-session
enhash NOHONOR     --no-honor-session
enhash ANTISOCIAL  --peers 1
enhash SOCIAL      --peers 6
enhash SEEDDEFAULT --seedratio-default
enhash NODOWNLIM   --no-torrent-downlimit
enhash NOUPLIM     --no-torrent-uplimit
enhash TINYUPLIM   --torrent-uplimit 2
enhash BEHAVE      cc NORMAL HONOR SOCIAL SEEDDEFAULT NODOWNLIM NOUPLIM
enhash HURRY       cc START HIGH TINYUPLIM
enhash SUPERSEED   cc START HIGH ANTISOCIAL
enhash GETOFF      cc START HIGH SOCIAL NOUPLIM

parsepeers() {
	TORR=${1//[^0-9]/}
	$TMISS_BIN -t $TORR -pi | tail -n +2 | awk '{
		if ($3 == "100.0") SEEX++
		else LEEX++
	} END {
		print int(LEEX) ":" int(SEEX)
	}'
}

[ "$1" == "PP" ] && { parsepeers $2; exit; }

stat_torr_list() {
for TORRENT in $@; do
	GOOD_RATIO=${TORRENT#*:}
	TORRENT=${TORRENT%:*}
	PEERSTATS=$( parsepeers $TORRENT )
	CONNSEEX=${PEERSTATS#*:}
	CONNLEEX=${PEERSTATS%:*}
	if [ "$CONDITION" == "info" ]; then
		$TMISS_BIN -t $TORRENT -i #| grep -iE 'Tracker #[0-9]+: '
		read
		continue
	elif [ "$CONDITION" == "all" ] || [ -z "$CONDITION" ]; then
		PRINTCOND="1"
	else
		PRINTCOND="$CONDITION"
	fi
	STATE=$(transmission-remote -t $TORRENT -i | awk '/State: / { print substr($0,10) }')
	$TMISS_BIN -t $TORRENT -i | awk 'BEGIN {
		SIZEW_SIDECOLS = 4
		TCOLS='$( tput cols )'
		STATE="'"$STATE"'"
		SEEDW=LEEXW=int(sprintf("%.0f",(TCOLS/7.6)))
		NAMECOLS=int(sprintf("%.0f",(TCOLS/6.7)))
		if (NAMECOLS < 12) NAMECOLS = 12
		SIZEW=TCOLS-NAMECOLS-SEEDW-LEEXW-3
		SIZEW_RATIO = SIZEW / (SIZEW - SIZEW_SIDECOLS)
		MAXMEGS = '"$TSLIT"' * SIZEW_RATIO
		MAXMEGS_MAGNIFICATION= '"$TSBIG"' * SIZEW_RATIO /MAXMEGS
		ALL=IGNORECASE=1
} function hr2b(num,units) { //human readable to bytes
	sub(/\/s/,"",units)
	if (num == "None")  return 0
	if (num == "Inf")   return 8796093022208 # 8 terabytes
	if (units == "TiB") return (num*1024*1024*1024*1024)
	if (units == "GiB") return (num*1024*1024*1024)
	if (units == "MiB") return (num*1024*1024)
	if (units == "KiB") return (num*1024)
	return num
} function hr2k(num,units) { return hr2b(num,units) / 1024
} function hr2m(num,units) { return hr2b(num,units) / (1024*1024)
} function dto36(dec) {
	backup = $0
	if ( ( "/usr/bin/php -r \"echo base_convert(" dec ",10,36);\"" ) | getline ) htd = $0
	$0 = backup
	close ( command )
	return htd
} function n(e)                          { return match(NAME,e)
} function bcharalg(num) {
	m = num * MAXMEGS / SIZEW
	if ((m % 200) > 100) return "#"
	return (int(m/100) % 10)
} function blocks_from_megs(megs) {
	blocks = megs
	return blocks
} function alternate_ending(orig,alt)    { return substr(orig,1,(length(orig)-length(alt))) alt
} function alternate_beginning(orig,alt) { return alt substr(orig,length(alt)+1)
} function str_repeat(str,times) {
	rtxt = ""
	for ( i = 0 ; i < times ; i++ ) rtxt = rtxt str
	return rtxt
} function end_only(str,chars)         { return substr(str,length(str)+1-chars)
} function beg_only(str,chars)         {	return substr(str,1,chars)
} function green_txt(str,beg,end,darkn) {
	revert = darkn ? "\033[22;35m" : "\033[22;39m"
	return substr(str,1,beg-1) "\033[22;32m" substr(str,beg,end+1-beg) revert substr(str,end+1)
} function dark_green_txt(str,beg,end,darkn) {
	revert = darkn ? "\033[22;35m" : "\033[22;39m"
	return substr(str,1,beg-1) "\033[2;32m" substr(str,beg,end+1-beg) revert substr(str,end+1)
} function green_txt_beg(str,num,darkn) { return green_txt(str,1,num,darkn)
} function dark_green_txt_beg(str,num,darkn) { return dark_green_txt(str,1,num,darkn)
} function color_bg(str,beg,end)       {
	return substr(str,1,beg-1) "\033[104m" substr(str,beg,end+1-beg) "\033[49m" substr(str,end+1)
} function yello_bg(str,beg,end)       {
	return substr(str,1,beg-1) "\033[44m" substr(str,beg,end+1-beg) "\033[49m" substr(str,end+1)
} function color_bg_beginning(str,num) { return color_bg(str,1,num)
} function yello_bg_beginning(str,num) { return yello_bg(str,1,num)
} function color_bg_ending(str,num)    { return color_bg(str,length(str)+1-num,length(str))
} function color_bg_all(str)           { return color_bg(str,1,length(str))
} function n2c(num)                    { return sprintf("%c",64+num)
} function red(str)  { return "\033[1;31m" str "\033[22;39m"
} function blue(str) { return "\033[1;35m" str "\033[22;39m"
} function dark(str) { return "\033[22;35m" str "\033[22;39m"
} function biggest_of(num1,num2) { return (num1 > num2) ? num1 : num2
}	/Tracker #[[:digit:]]+: .*tvtorrents.com/ { TVT=1 }
	/Got a list of  /		{ PREVPCNT	= $5 }
	/Date added: /			{ ADATE		= ( "date -d \"" substr($0,23) "\" +%s" | getline t ) ? t : 0 }
	/Date created: /		{ CDATE		= ( "date -d \"" substr($0,20) "\" +%s" | getline t ) ? t : 0 }
	/Latest activity: /	{ LACT		= ( "date -d \"" substr($0,20) "\" +%s" | getline t ) ? t : 0 }
	/Name: /					{ NAME		= substr($0,9) }
	/Id: /					{ ID			= substr($0,7) }
#	/State: /				{ STATE		= substr($0,10) }
	/Peers: /				{ PEERS		= substr($4,1,length($4)-1) }
	/Upload Speed: /		{ UP			= hr2k($3,$4) }
	/Download Speed: /	{ DOWN		= hr2k($3,$4) }
	/Piece Count: /		{ PC			= (substr($0,16) + 0) }
	/Piece Size: /			{ PS			= hr2b($3,$4) }
	/Uploaded: /			{ BYTESUP	= hr2b($2,$3) }
	/Downloaded: /			{ BYTESDOWN	= hr2b($2,$3) }
	/Total size: /			{ BYTESTOTG	= hr2b($3,$4) } #never actually use it, just use piece data
	/Have: /					{ BYTESHAVE	= hr2b($2,$3) }
	/Percent Done: / {
		PERCENT_DONE=substr($0,17)
		sub(/%/,"",PERCENT_DONE)
		PERCENT_DONE += 0
	} /Ratio: / {
		RATIO=substr($0,10)
		if ((RATIO == "Inf") || (RATIO == "None")) {
			RATIO = '$GOOD_RATIO'
		}
		if (RATIO == "Inf") RATIO=999
		if (RATIO == "None") RATIO=0
		RATIO += 0
	} /ETA: / {
		$1=""
		sub(/ */,"")
		ETA=$0
	} /Tracker had / {
		seedarr[seedcount++] = $3
		leexarr[leexcount++] = $6
} END {

		THIS_SECOND = ( "date +%s" | getline t ) ? t : 0
		DAYS_SINCE_ADDED = (THIS_SECOND - ADATE) / 86400
		WEEKS_SINCE_ADDED = (THIS_SECOND - ADATE) / 604800
		MONTHS_SINCE_ADDED = (THIS_SECOND - ADATE) / 2629743.768
		BLOCKS_SINCE_ADDED = NAMECOLS * (THIS_SECOND - ADATE) / (THIS_SECOND - 1247272080)
		if (!(LACT > 99999)) LACT = CDATE
		DAYSSINCEACTIVE = ( systime() - LACT ) / 86400
		if (DAYSSINCEACTIVE > 999) DAYSSINCEACTIVE = 999

		seedcount = asort(seedarr)
		leexcount = asort(leexarr)
		SEEDS = seedarr[seedcount]
		LEEX = leexarr[leexcount]
		SPEERS = '"${CONNSEEX}"'
		LPEERS = '"${CONNLEEX}"'
		PHANTOM_LEECHERS = PREVPCNT - biggest_of(SEEDS,SPEERS)
		HAS_PEERLIST = (seexcount || leexcount || SPEERS || LPEERS)
		HUNG = (SEEDS < 1) && (SPEERS < 1)

		DONE = PERCENT_DONE >= 100

		TOTAL_BYTES_VIA_PIECE_DATA	= PC * PS
		TOTAL_BYTES_IMPLIED			= 100 * BYTESHAVE / ((PERCENT_DONE == 0) ? 0.01 : PERCENT_DONE)
		FUNCTIONAL_SIZE = ((TOTAL_BYTES_IMPLIED > 0) && ((TOTAL_BYTES_VIA_PIECE_DATA-TOTAL_BYTES_IMPLIED) > 134217728)) \
			? TOTAL_BYTES_IMPLIED : TOTAL_BYTES_VIA_PIECE_DATA
#		DEBUGTXT = " " sprintf("%1.0f",TOTAL_BYTES_VIA_PIECE_DATA)
		BYTES_STILL_NEEDED = (100 - PERCENT_DONE) * FUNCTIONAL_SIZE / 100
		DMEGS = BYTES_STILL_NEEDED / (1024*1024)
		if (BYTESDOWN < BYTESHAVE) BYTESDOWN = BYTESHAVE
		if (BYTESDOWN <= 0) BYTESDOWN = 0.01
		RATIO = BYTESUP/BYTESDOWN
		DEBT_RATIO = (RATIO > 1) ? 0 : ((RATIO < 0) ? 1 : (1 - RATIO) )
		BYTES_STILL_OWED = DEBT_RATIO * FUNCTIONAL_SIZE
		MEGS = FUNCTIONAL_SIZE / (1024*1024)
		DEBT_MEGS = BYTES_STILL_OWED / (1024*1024)
		SIGNIFIGANT_MEGS_LEFT = (DONE ? BYTES_STILL_OWED : BYTES_STILL_NEEDED) / (1024*1024)
		if (SIGNIFIGANT_MEGS_LEFT > MAXMEGS) MAXMEGS *= MAXMEGS_MAGNIFICATION
		ALMOSTDONE = !DONE && (BYTES_STILL_NEEDED <= 174063616) #166mb
		ALMOST_DONE = ALMOSTDONE

		STATE_FIRST_TEN = substr(STATE,1,10)
		VERIFYING = (STATE_FIRST_TEN == "Verifying") || (STATE_FIRST_TEN == "Will Verif")
		RUNNING = (STATE != "Stopped") && !VERIFYING
		UPPING  = (STATE == "Seeding") || (STATE == "Up & Down") || (STATE == "Uploading")
		DOWNING = (STATE == "Downloading") || (STATE == "Up & Down")
		ACTIVE =  RUNNING && (STATE != "Idle")


		OFFTHEHOOK = (RATIO > 1) && DONE && (SEEDS > 1)
		ALMOSTOFFTHEHOOK = (DEBT_MEGS <= 166) && DONE && (SEEDS > 1)
		ONLYSEEDISPROBSME = UPPING && DONE && (SEEDS < 2)
		IMMINENT = (SIGNIFIGANT_MEGS_LEFT > 0 ) && (SIGNIFIGANT_MEGS_LEFT < 300)
		DEAD = !ACTIVE && !DONE && (SEEDS < 1)
		COMPLETELY_OFFTHEHOOK = OFFTHEHOOK && !RUNNING
		INTERESTING = !COMPLETELY_OFFTHEHOOK && !DEAD


		if (!('"${PRINTCOND}"')) exit 1


		NUMBLOCKS       = ((MEGS      > MAXMEGS) ? MAXMEGS : MEGS)      * SIZEW / MAXMEGS
		NUM_DOWN_BLOCKS = ((DMEGS     > MAXMEGS) ? MAXMEGS : DMEGS)     * SIZEW / MAXMEGS
		NUM_DEBT_BLOCKS = ((DEBT_MEGS > MAXMEGS) ? MAXMEGS : DEBT_MEGS) * SIZEW / MAXMEGS

		CTXT = str_repeat("_",NUMBLOCKS)
		CTXT = alternate_ending(CTXT,str_repeat("!",NUM_DEBT_BLOCKS))
		if (DONE) {
			if (DEBT_MEGS > 0) CTXT = alternate_ending(CTXT,sprintf("%1.0f",DEBT_MEGS))
			else CTXT = alternate_ending(CTXT,sprintf("%1.2f",RATIO))
		}
		CTXT = alternate_ending(CTXT,str_repeat("#",NUM_DOWN_BLOCKS))
		CBLANKS = str_repeat(" ",SIZEW)
		if (!DONE && ACTIVE) CBLANKS = alternate_beginning(CBLANKS,ETA)
#		else if (RUNNING && (DAYSSINCEACTIVE > 1)) CBLANKS = alternate_beginning(CBLANKS,sprintf("%3.0f",DAYSSINCEACTIVE))
#		else CBLANKS = alternate_beginning(CBLANKS,int(DAYSSINCEACTIVE))
		CTXT = alternate_ending(CBLANKS,CTXT)
		if (MEGS > MAXMEGS) {
			GIGS = MEGS / 1024
			FTXT = (GIGS >= 10) ? "%2.0f" : "%3.1f"
			CTXT = alternate_beginning(CTXT,sprintf(FTXT,GIGS) DEBUGTXT)
		}
		if (DMEGS > 0) { CTXT = alternate_ending(CTXT,sprintf("%1.0f",(DMEGS))) }
		if (!DONE && RUNNING) sub(/([0-9\.]*#+)?[0-9\.]*$/,red("&"),CTXT)
		else if ((RATIO < 1) && RUNNING) sub(/([0-9\.]*!+)?[0-9\.]*$/,blue("&"),CTXT)

		STATE_TXT = ((STATE == "Downloading") || (STATE == "Uploading") || (STATE == "Seeding") || (STATE == "Up & Down") ) ? "*"\
			: (STATE == "Idle") ? "-"\
			: VERIFYING ? "V"\
			: (STATE == "Stopped") ? " " : "?"

		NTXT = str_repeat("_",NAMECOLS)
		NTXT = alternate_beginning(NTXT,substr(NAME,0,NAMECOLS))
		NTXT = alternate_ending(NTXT,"_" ID)
		NTXT = RUNNING ?
				  green_txt_beg(NTXT,BLOCKS_SINCE_ADDED,!RUNNING) :
			dark_green_txt_beg(NTXT,BLOCKS_SINCE_ADDED,!RUNNING)

		LTXT = str_repeat("-",PHANTOM_LEECHERS)
		LTXT = alternate_ending(LTXT,str_repeat("_",LPEERS))
		for (l = leexcount ; l > 0 ;l--) LTXT = "" alternate_ending(LTXT,str_repeat(n2c(l),leexarr[l]))
		if (length(LTXT) > LEEXW) LTXT = alternate_beginning(end_only(LTXT,LEEXW), leexarr[leexcount] n2c(leexcount) "*" )
		LTXT = alternate_ending(str_repeat(" ",LEEXW),LTXT)
		if (DOWNING && (DOWN > 0)) LTXT = color_bg_beginning(LTXT,int(DOWN+0.5))

		STXT = str_repeat("_",SPEERS)
		for (s = seedcount ; s > 0 ;s--) STXT = alternate_beginning(STXT,str_repeat(n2c(s),seedarr[s]))
		if (length(STXT) > SEEDW) STXT = alternate_ending(beg_only(STXT,SEEDW), "*" n2c(seedcount) seedarr[seedcount] )
		STRRP_CHAR = (!RUNNING && SEEDS < 1) ? "-" : " "
		STXT = alternate_beginning(str_repeat(STRRP_CHAR,SEEDW),STXT)
		if (UPPING  && (UP   > 0)) STXT =    color_bg_ending(STXT,int(UP+0.5))

		SIGS_LEFT_RANKING = SIGNIFIGANT_MEGS_LEFT * 9999999999 / 999999
		RATIO_RANKING = 9999999999 - (RATIO * 9999999999 / 999999)
		SEPCHAR = (HAS_PEERLIST && (DAYSSINCEACTIVE < 1)) ? ":" : " "
		OUTPUT_FORMATTING =	((DOWNING) ? "%s" "%1s%s " red("%s") : "%s%1s%s %s" ) \
									((ACTIVE) ? red(SEPCHAR) : SEPCHAR) \
									((UPPING) ? red("%s") : "%s")
		OUTPUT = sprintf ( OUTPUT_FORMATTING, CTXT, STATE_TXT, NTXT, LTXT, STXT )
		printf "%10.0f %010.0f %10.0f %s", 3, SIGS_LEFT_RANKING, RATIO_RANKING, ((RUNNING) ? OUTPUT : dark(OUTPUT))
}'
	[ $? -gt 0 ] || {
		ACTION=${ACTION^^} #uppercase
		ACTION=${ACTION//[^A-Z]/} #sanitize
		if [ -z "${ACTION}" ]; then echo
		elif ckhash "${ACTION}"; then
			TRCOMMAND="$TMISS_BIN -t $TORRENT "$( unhash "${ACTION}" )
			echo -ne "\e[1;34m"
			echo -n $(date +%a\ %l:%M:%S) $TRCOMMAND
			echo -ne "\t...\t"
			echo -n $( eval $TRCOMMAND ) # | grep -vi success 
			echo -e "\e[0m"
		else
			echo "unknown action..."
		fi
	}
done
}

CONDITION=$1
ACTION=$2

#tail -n +2
TORRENTS=$( $TMISS_BIN -l | head -n -1 | awk 'BEGIN {
	OUT=0
	thisrecnum=0
} function pretend(pretend_zero,pretend_field) {
	B0 = $0
	$0 = pretend_zero
	rvar = $pretend_field
	$0 = B0
	return rvar
} function category_from_name(given_name) {
	g = tolower(given_name)
	if (match(g,/miriam/)) return "40_hopeless"
	if (match(g,/(jeffrey|fr1|queer|watermelon|ftbyam|clarissa|kazablan|flag wars|sw|p175|dfg|milk)/)) return "99_homemade"
	if (match(g,/(ugly betty season 3|law & order svu season|koth season 11|beautiful.people|law and order special|king of the hill seaso|ugly betty - season 4)/)) return "50_tvtorrents"
	return "01_thereest"
} function shift(str) {
	B0 = $0
	rvar = substr($0,length($1)+1)
	$0 = B
	return rvar
} {
	if (match($0,/^ID.*Down/)) {
		COLS_BEFORE_RATIO=RLENGTH+2
		if (match($0,/^ID.*Name/)) {
			COLS_BEFORE_NAME=RLENGTH-3
		}
		next
	}
	thisrecnum++

	ID=$1

	#if (ID != 48) next #for testing kazablan, whose size falls between columns

	RATIO = pretend(substr($0,COLS_BEFORE_RATIO),1)
#	NAME = substr($0,COLS_BEFORE_NAME)
#	gsub(/[ 	.()@[\]-]/,"_",NAME)
	CATEGORY = category_from_name(substr($0,COLS_BEFORE_NAME))

#	print ID ":" RATIO

#	printf("%4s %8s %10s \n",ID,RATIO,CATEGORY)
	RECORD[thisrecnum] = CATEGORY " " RATIO " " ID
} END {
#	numrecs = thisrecnum
	for ( rec = asort(RECORD) ; rec > 0 ; rec-- ) {
#		print RECORD[rec]
#		shifted_rec = shift(RECORD[rec])
		print pretend(RECORD[rec],3) ":" pretend(RECORD[rec],2)
#		printf(" %10s %8s %4s\n",pretend(RECORD[rec],1),pretend(RECORD[rec],2),pretend(RECORD[rec],3))
	}
}' | tr -d '*' )

#stat_torr_list "87:0.29 10:None" #| sort -n | colrm 1 $COLRMS
stat_torr_list $TORRENTS | sort -n | colrm 1 $COLRMS
