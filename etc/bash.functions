############# ABSTRACTIONS
uniq_token()	{ echo $(date +%s).$(printf "%05d" $RANDOM); }
am_root()		{ [ "x$EUID" == "x0" ]; }
say_and_do()	{ echo DOING: "$@"; "$@"; }
return_arg1()	{ return "$1"; }
isnt()			{ eval "$@"; [ $? -ne 0 ]; }
wait_until()	{ while isnt "$@"; do sleep 0.5; done; }
weekletter()	{ ARR=(S m t w T f s S); echo ${ARR[$(date +%u)]}; }
############# PROCESS MANIP
process_exists() { return $( ps --pid $1 -o pid= >/dev/null 2>&1 ); }
alias pid_exists="process_exists"
ppid_from_pid() {
	[ -z "$1" ] && return
	[ -z "$2" ] || GREPTEXT=' | grep -i'"$2 "
	ps -p "$1" -o ppid= $GREPTEXT | awk '{ print $1 }' # | tail -n -1
}
do_unto_others() { # usage: do_unto_others [niceness [ioniceness [pid [show]]]]
	renice -n ${1:- 19}   ${3:- $$} >/dev/null
	ionice -c ${2:- 3} -p ${3:- $$} >/dev/null
	[ "$4" = "show" ] && ionice -p ${3:- $$} # display what it accomplished...
}
niceify_tree() { # usage: niceify_tree [pid [niceness [ioniceness]]]
	local INDENT=$INDENT"   "
	echo "${INDENT:3}"$( ps --pid $1 -o comm= )" "$(do_unto_others ${2:- 19} ${3:- 3} $1 show)
	for CHILD in $( ps --ppid $1 -o pid= ); do
		niceify_tree $CHILD ${2:- 19} ${3:- 3}
	done
}
family_therapy() {
	 pid_exists $1 && INDENT="" niceify_tree $1 ${2:- 19} '3' || echo no such process
}
############# FILE MANIP
full_path() {
   echo -n "$( readlink -f "$( dirname "$1" )" )/$( basename "$1" )"
}
full_path_lax() {
   echo -n "$( readlink -m "$( dirname "$1" )" )/$( basename "$1" )"
}
full_path_strict() {
   echo -n "$( readlink -e "$( dirname "$1" )" )/$( basename "$1" )"
}
repermit() {
	for TARGET; do
		[ -e "$TARGET" ] || continue
		find "$TARGET" -type d -exec chmod 750 {} \;
		find "$TARGET" -type f -exec chmod 640 {} \;
	done
}
bootable() {
	DATA=$( od -A x -j 510 -N 2 -w16 -t x2 "$1" | colrm 1 7 )
	[ "$DATA" == "aa55" ] && echo "$1 is bootable" >&2 || {
		echo "$1 is not bootable" >&2
		return 1
	}
}
is_empty_dir() {
	 D=$(find "$1" -maxdepth 0 -type d -empty)
	 [ "$D" ]
}
enforce_perms() {
	 [[ "$1" =~ [0-7]{3} ]] || return 1 #perm string is valid
	 [ -a "$2" ] || return 1            #file exists
	 STATS=$(stat -c %a "$2")
	 [[ "$1" == "$STATS" ]] || {
		  ls -FlAthr "$2"
		  say_and_do chmod "$1" "$2" #chmod file if not set already
	 }
}
############ INTERACTIVE CONSOLE TRICKS
cursor_position() { # http://invisible-island.net/xterm/xterm.faq.html
	 exec < /dev/tty
	 oldstty=$(stty -g)
	 stty raw -echo min 0
	 echo -en "\033[6n" > /dev/tty
	 IFS=';' read -r -d R -a pos
	 stty $oldstty
	 col=$((${pos[1]} - 1))
	 echo $col
}
at_line_start() {
	 CP=$(cursor_position)
	 return $CP
}
clear_line() {
	 echo -ne "\r"
	 let NUMCHARS=$( tput cols )
	 while let NUMCHARS--; do
		  echo -n ' '
	 done
	 echo -ne "\r"
}
clear_echo() {
	 at_line_start || echo
	 echo "$@"
}
countdown() {
   COUNT=$1
	NUMCHARS=${#COUNT}
   while let COUNT--; do
      echo -ne "  $COUNT  "
      sleep 1
      echo -ne "\b\b\b\b"
		I=$NUMCHARS
		while let --I; do
			 echo -ne "\b"
		done
   done
}
clear_input_buffer() {
    #example: clear_input_buffer "clearing input buffer..." "ok\n"

    while true; do
        read -p "$1" -t 0.0001 -n 32767 ENTERED
        [ $? -gt 128 ] && break
    done
    echo -ne "$2"
}
askyn() {
	 QUESTION="$@"
	 echo
	 clear_input_buffer
	 read -N 1 -p "$QUESTION [*/n]): " USERINPUT
	 case $USERINPUT in
		  n) return 1;;
		  *) return 0
	 esac
}
giveup_prompt() {
	askyn "$@" && continue 2 || break 2
}
############ WRAPPERS
ll() {
	if [ $# -gt 1 ]; then
		ls --color=auto -FlAthrd "$@"
	else
		ls --color=auto -FlAthr  "$@"
	fi
}
lls() {
	ll | head -n 10
}
make_bash_script() {
	[ -f "$1" ] && return 1
	echo	'#!/bin/bash' > "$1"
	chmod +x "$1"
	e "$1"
}
ups() {
	apcaccess status | grep -Ei '^(status|linev|loadpct|bcharge|timeleft)'
}
woman() {
	local IFS='
';	[ "$1" ] && COMMAND="$@" || {
		echo -n "Enter command to look up: "
		read COMMAND
		echo
	}
	set_xtitle "$COMMAND [woman]"
	help "$COMMAND" 2>/dev/null && read || e\
		--eval '(fset '"'"'manpage "man '$COMMAND' | cat && exit\C-m")'\
		--eval '(shell)'\
		--eval '(execute-kbd-macro (symbol-function '"'"'manpage))'\
		--eval '(beginning-of-buffer)'\
		--eval '(beginning-of-buffer)'\
		--eval '(beginning-of-buffer)'\
		--eval '(beginning-of-buffer)'\
		--eval '(beginning-of-buffer)'\
		--eval '(beginning-of-buffer)'
}
wf() {
	[ "$1" ] || return
	PWD_B=$(pwd)
	cd ~
	local IFS=:
	for P in $PATH; do
		[ -a "$P" ] || continue
		find "$P" | grep -i "$1"
	done
	cd "$PWD_B"
}
e() {
	case "$TERM" in
		 linux)                     emacs "$@";;
		 *)     TERM=xterm-256color emacs "$@"
	esac
}
plyst() {
    pacman -r /aufs-ro \
	--dbpath /aufs-ro/var/lib/pacman \
	--config /etc/pacman.conf \
	--logfile /var/log/pacman.log\
	--cachedir /root/snowball/pkgcache -Ss "$1" | tr '\n' '#' | sed 's%#    % %ig' | tr '#' '\n' | sed 's%^[a-z]*/%%i' | sort | awk '{
	twotxt = ""
	spaces = length($1)
	maxl = 20
	for ( i = maxl ; i > spaces ; i-- ) twotxt = twotxt " "
	$2 = twotxt
	print $0	
}'
}
iptables-all() {
	 iptables -t filter	-L -v -x --line-numbers
	 iptables -t raw		-L -v -x --line-numbers
	 iptables -t nat		-L -v -x --line-numbers
	 iptables -t mangle	-L -v -x --line-numbers
}
drome() {
#	 create a new window in screen, open screen & switch to it
#	 USAGE: drome [title [command [args]]]
	 TOKEN=${1:-$(uniq_token)}
	 shift
	 screen -p - -X screen -t $TOKEN "$@"
	 screen -x -R -p $TOKEN
}
run_in_temp_memdir() {
	[ "$UID" -eq 0 ] && return
	INMEM=/media/inmem
	FOLFSEEY342534="$INMEM"/$( uniq_token )
	mkdir "$FOLFSEEY342534"
	cd "$FOLFSEEY342534"
	do_in_temp_memdir "$@"
	cd
	rm -rf "$FOLFSEEY342534"
}
in_2_but_not_in_1() {
	 BIFS=${IFS}
	 IFS=:
	 for P in $2; do
		  IFS=' '
		  P=$(readlink -e $P 2>/dev/null || echo INVALID)
		  [[ $P == 'INVALID' ]] && continue
		  [[ "$1" =~ (^|:)$P(:|$) ]] || echo $P
		  IFS=:
	 done
	 IFS=${BIFS}
}
do_fail() {
   read -p "$*" CHAR
   return 1
}
test_network_once() {
   /usr/bin/wget -q --tries=30 --timeout=30 http://www.google.com/ -O - 2>/dev/null | grep -iq 'feeling lucky'
}
wait-for-network() {
	 SLEEPINC=1.5
	 while test_network_once; do
		  echo $( date +%a\ %H:%M:%S ) No internet yet, waiting...
		  sleep $SLEEPINC
		  SLEEPINC=$(echo "scale=30; $SLEEPINC*1.2" | bc )
	 done
	 echo yay, internet is up!
}
ramsize() { #returns size of system's ram in megabytes
	 awk '/MemTotal:/ { printf ("%0.0f\n",$2/1024); }' /proc/meminfo
}
ramfree() { #returns ${1}% size of free ram in megabytes
	 awk '/MemFree:/ { printf ("%0.0f\n",($2 * '${1}')/(1024 * 100)); }' /proc/meminfo
}
comm_front() {
	 A=${1};
    CP=$(cursor_position);
    [ $CP -eq 0 ] || echo -en '\e[1;41m<->\e[m';
    [ $A -eq 0 ] || echo "[${1}] "
}
print_jobs() {
	 jobs | while read J; do
		  echo -n \*
	 done
}
list_sorted() {
	 for F; do
		  echo ${F}
	 done | sort -u
}
