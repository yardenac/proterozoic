#!/bin/bash
. /etc/rc.conf
. /usr/share/ppz/bash.functions

# functions should not assume anything. We might be running:
#   with or without root privs
#   interactively or with messed up input/output
#   before or after rc.multi scripts (they could be backgrounded!)
#   inside a chroot - use chrooted() from bash.functions

integrity_rootpw() {
	 am_root && shell_is_interactive || return 0

	 grep -iq ENCRYPT_METHOD /etc/login.defs || \
		  echo "ENCRYPT_METHOD SHA512" >> /etc/login.defs

	 # this is messy and needs attention
	 # checking is not this easy - hash is seeded
	 # write a program that simulates login to check?
	 # ^ should work for non-root user too!

	 while :; do
		  roothash=$(awk 'BEGIN {FS=":"} /^root:/ {print $2}' /etc/shadow)
		  case $roothash in
				'') askyn "Root pw sucks! Set it?" && passwd || return;;
				*) break
		  esac
	 done
}
integrity_locales() {
	 am_root || return 0
	 local L=$(locale)
	 [ "${L}" ] && return #has locale, so ok
	 askyn "You have no locale!? Should we fix this?" \
		  && echo "Oops, Not implemented yet..."
}
integrity_tz() {
	 am_root || return 0
	 local suspicious_tzs=(America/Vancouver America/New_York)
	 local matches=0
	 for stz in "${suspicious_tzs[@]}"; do
		  cmp -s /etc/localtime /usr/share/zoneinfo/$stz && let matches++
	 done
	 (( $matches )) || return 0
	 [ -a /etc/localtime.userok ] && return
	 local c=22; while let c--; do
		  usetvar TZONE "You have a default arch timezone. To keep it, press C-c or C-\ ...
To replace it, pick a new one: " /usr/share/zoneinfo/America/Los_Angeles USERCANCELLED || {
				echo_red "Still using default time zone!"
				break
		  }
		  [ "$TZONE" = "USERCANCELLED" ] && { #THIS WILL NEVER RUN! IT'S BROKEN!
				echo "If this file exists, it means the system is SUPPOSED to" \
					 "have the default timezone (Vancouver or NY). Otherwise," \
					 "root would always be prompted to change it." > /etc/localtime.userok
				echo_red "Default timezone kept. You won't be asked again."
				break
		  }
		  [ -f ${TZONE} ] && {
				cp -f ${TZONE} /etc/localtime
				break
		  }
		  echo_blue "That timezone doesn't exist."
	 done
}
integrity_simpleconf() {
	 am_root || return 0
	 grep -iEq ^/usr/bin/womb$ /etc/shells || echo /usr/bin/womb >> /etc/shells
	 grep -iEq '^sshd[ :	]*ALL[ :	]*ALLOW$' /etc/hosts.allow 2>/dev/null \
		  || echo 'sshd : ALL : ALLOW' >> /etc/hosts.allow
	 sed -i 's%^\(/bin/rm -rf /tmp.*\)$%\#\1%ig' /etc/rc.sysinit #comment
	 case $SYSTEM_TYPE in
		  linode)				sed -i 's/MODULES="btrfs dm-crypt dm-mod dm-snapshot fuse"/MODULES=""/ig' /usr/lib/initcpio/install/ppz_tmp
									sed -i 's%^\#\(server clock.fmt.he.net.*\)$%\1%ig' /etc/ntp.conf;;
		  desktop|laptop|*)	sed -i 's%^\(server clock.fmt.he.net.*\)$%\#\1%ig' /etc/ntp.conf;;
	 esac
	 case "$(uname -m)" in
		  i686)		sed -i 's/^\[multilib\]$/#&/ig'			/etc/pacman.conf;;
		  x86_64)	sed -i 's/^##*\(\[multilib\]\)$/\1/ig'	/etc/pacman.conf;;
	 esac
	 mkdir -p /media/{arch-cold-r{w,o},rodinia,green}
	 [ -L /snowball ] || ln -s media/rodinia/pub /snowball
	 [ -a /usr/share/terminfo/r/rxvt-unicode-256color ] || \
		  ln -s /usr/share/terminfo/r/rxvt{,-unicode}-256color
	 enforce_perms 440 /etc/sudoers.d/wheel

	 sed -i 's%^\(MIRRORLIST="/etc/pacman.d/mirrorlist"\)$%\#\1%ig' /etc/abs.conf
	 grep -qiE '^MIRRORLIST="/etc/pacman.d/mirrorlist.otown"$' /etc/abs.conf || \
		  echo 'MIRRORLIST="/etc/pacman.d/mirrorlist.otown"' >> /etc/abs.conf

	 # php tmpdir
	 if grep -q ^http: /etc/passwd && grep -q ^http: /etc/group; then
		  [ -d /tmp/php ] && [ $(stat -c %U /tmp/php) = "http" ] || {
				rm -rf /tmp/php
				mkdir /tmp/php
				chown -R http:http /tmp/php
		  }
	 fi
	 local wpaf=/etc/wpa_supplicant.conf
	 [ "$WPA_SC" ] && [ -s $wpaf ] && [ -s "$WPA_SC" ] && ! diff $wpaf "$WPA_SC" && {
		  echo_red "$wpaf is outdated"
		  am_root && askyn "Update from $WPA_SC ... ?" && cp -f "$WPA_SC" "$wpaf"
	 } || :
}
integrity_inittab() {
	 am_root || return 0

	 # the one we want to be like
	 local model=x
	 case $SYSTEM_TYPE in
		  linode) model=linode;;
#		  desktop|laptop|*) :;;
	 esac

	 cmp -s /etc/inittab /usr/share/ppz/default/inittab.$model || {
		  echo_red "Fixing inittab to use the '$model' setup!"
		  cat /usr/share/ppz/default/inittab.$model >| /etc/inittab
	 }
}
integrity_hosts() {
	 am_root || return 0
	 local OLDFILE=/etc/hosts
	 local NEWFILE=/tmp/root.etchosts.$(uniq_token)
	 {
		  cat <<-EOF
			THISVER 2012101901
			ASSIGN 127.0.0.1		localhost.localdomain   localhost ${HOSTNAME} ${HOSTNAME_ALIASES}
			ASSIGN ::1				localhost.localdomain   localhost ${HOSTNAME} ${HOSTNAME_ALIASES}
			ASSIGN fe00::0			ip6-localnet
			ASSIGN ff00::0			ip6-mcastprefix
			ASSIGN ff02::1			ip6-allnodes
			ASSIGN ff02::2			ip6-allrouters
			ASSIGN ff02::3			ip6-allhosts
			ASSIGN 192.168.1.242 drog
			ASSIGN 192.168.1.243 bro
			ASSIGN 192.168.1.244 iggy
			ASSIGN 192.168.1.245 tuya
			ASSIGN 192.168.1.246 nudi
			ASSIGN 208.111.39.115 g w m k s se es he eh map y b r aur arch archp n news o
			EOF
		  cat ${OLDFILE}
	 } | awk -f /usr/share/ppz/awk-hosts > ${NEWFILE}
	 cmp -s ${OLDFILE} ${NEWFILE} || {
		  mv ${OLDFILE}{,.orig.$(uniq_token)}
		  mv ${NEWFILE} ${OLDFILE}
		  echo ${HOSTNAME} >| /proc/sys/kernel/hostname
	 }
	 rm -f ${NEWFILE}
}
integrity_users() {
	 am_root || return 0

	 # "extra" users are declared in rc.conf. this makes sure they really exist.

	 local user v u_name u_nums u_home IFS=$'\n'
	 for user in $(awk '/^:/ { if ($2 == "user") print }' /etc/rc.conf); do

#		  echo_red "DOING USER: $user"

		  IFS=$'\n\r\t ' v=($user)
		  u_name=${v[2]}
		  u_nums=${v[3]}
		  u_home=$(edev-path ${v[5]}) || {
				echo_red "homedir ${v[5]} on undeclared encrypted device!"
				continue
		  }
		  # if we're still here, u_home is now a real path :)
		  # it's not the job of this function to CREATE the path
		  # if user isn't in passwd, create it
		  # this should use getent, not grep! TODO
		  grep -qiE "^${u_name}:" /etc/passwd || {
				echo_red "adding user ${u_name}!"
				useradd -lMNd ${u_home} -u ${u_nums%%:*} -g ${u_nums##*:} -s ${v[4]} ${u_name}
				echo $u_name:\' | chpasswd
		  }
	 done

	 # only works up to 10...
	 local luser pw homefull uc=0 #user count
	 for luser in "${SSH_USERS[@]}"; do
		  if [ ${luser:0:1} = "@" ]; then
				let uc++
				luser=${luser#@}

				# make user
				grep -q ^$luser: /etc/passwd || {
					 useradd -lMNd /home/$luser -u 5433$uc -u 100 -s /bin/false $luser
					 pw=$(random_password)
					 echo $luser:$pw | chpasswd
					 echo "New password for $luser is: $pw"
				}

				# make dirs
				homefull=/home/wall/$luser/home/$luser
				mkdir -p $homefull/www
				[ "$(readlink -e /home/$luser)" = $homefull ] || {
					 rm -rf /home/$luser
					 ln -s $homefull /home/$luser
				}
				chown $luser:users $homefull
				chmod 755 $homefull
				[ "$pw" ] && echo $pw >| $homefull/.pw || :
		  fi
	 done
}
integrity_iptables() {
	 am_root || return 0

	 # this only works on the FILE. it does not interact directly with the tables,
	 # except to call rc restart. only use rc for that, much cleaner that way!
	 local PROTOCOL PORT CUSTOM= \
		  rules_file=/etc/iptables/iptables.rules \
		  default_rules=/usr/share/ppz/default/iptables.rules \
		  tmp_is=/tmp/iptables.is.$(uniq_token) \
		  tmp_should=/tmp/iptables.should.$(uniq_token)

	 # rules as they should be, WITH custom open ports from rc.conf
	 for PORT in ${OPEN_PORTS[@]}; do
		  PROTOCOL=tcp
		  [[ ${PORT} =~ : ]] && PROTOCOL=${PORT%%:*}
		  [ "$CUSTOM" ] && CUSTOM+='\n'
		  CUSTOM+="-A open -p ${PROTOCOL} -m ${PROTOCOL} --dport ${PORT##*:} -j ACCEPT "
	 done
	 sed 's/^#LOCAL$/'"$CUSTOM"'/ig' $default_rules > $tmp_should

	 # current rules with comments & empty lines removed, and counters zeroed
	 touch $rules_file
	 sed 's/^\(#.*\)\?$//ig;Tc;d;:c;s/\[[0-9]*:[0-9]*\]/[0:0]/ig' $rules_file > $tmp_is

	 # if they're different, deal with that
	 if ! [ -s $tmp_is ] || ! diff $tmp_is $tmp_should; then
		  if ! [ -s $tmp_is ] || askyn "Impose new iptables rules?"; then
				cat $tmp_should >| $rules_file
				echo_red replaced iptables rules
				chrooted && echo_red "Not resetting iptables" || /etc/rc.d/iptables restart
		  fi
	 fi

#	 askyn "are you inspecting the iptables sitch?"

	 rm -rf $tmp_is $tmp_should
}
can_work_with_boot() {
	 grep -iq /boot /etc/fstab \
		  && ! [ -d /boot/grub ] \
		  && return 1 #should be mounted but isnt
	 [ -w /boot ] && return #can write to it - ok
	 findmnt -n /boot >/dev/null && return 1 #probably chrooted
	 mount -o remount,rw /boot &>/dev/null
	 [ -w /boot ] || return 1 #weve done all we can
}
remote_sync_file() { # $0 '/local/path' 'md5sum464a702cf...' 'http://source'
	 check_file ${1} ${2} && return
	 [ "${1:0:6}" = /boot/ ] && ! can_work_with_boot && return 1
	 mkdir -p $(dirname ${1})
	 wget ${3} -qO ${1}
	 check_file ${1} ${2} && {
		  echo_red "Successfully retrieved $1"
	 } || {
		  rm -f ${1}
		  echo_red "Problem downloading $1 - have to get it later"
	 }
	 [ "${1:0:6}" = /boot/ ] && mount -o remount,ro /boot &>/dev/null; :
}
integrity_net() {
	 if test_network_once 5; then
		  ! python-ntp && am_root && askyn "Sync kernel & hwclock with ntpdate?" && {
				ntpdate pool.ntp.org
				echo "0.0 0 0.0" > /var/lib/hwclock/adjtime
				hwclock --systohc --utc
		  }
	 else
		  echo -n "No fast connectivity... Local system time: "
		  echo_red $(date '+%l:%M:%S (%A %B %e, %Y)')
		  return
	 fi
	 am_root && {
		  grep -iq broadcast /etc/rc.d/network || {
				mv -f /etc/rc.d/network{,.forget}
				wget http://projects.archlinux.org/initscripts.git/plain/network -qO /etc/rc.d/network
				chmod +x /etc/rc.d/network
				askyn "Had to replace netscript from git! Did download work ok?" && rm -f /etc/rc.d/network.forget
		  }
		  eval $(awk '/^:/ {
				if ($2 == "sync") {
					printf "remote_sync_file %s %s %s;\n", $3,$4,$5
				}
		  }' /etc/rc.conf)
	 }
	 return 0
}
integrity_encdev() {
	 local size arg name type dev{,_canon,_intermediate} mountpoint mapname loop mem iters IFS=$'\n\r\t '

	 # makes sure device exists and is luks
	 # creates it with default key if necessary

	 # if making it the FIRST time, we open it once to format it.
	 # otherwise, we dont open it

#	 echo_red "DOING ENCDEV: $@"

	 name=$3
	 dev=$4
	 size=32m
	 mapname=$name
	 mountpoint=/media/$name
	 shift 4
	 for arg; do
		  shopt -s nocasematch
		  if [ ${arg:0:1} = / ]; then 						# it's a path, mountpoint
				mountpoint=$arg
		  elif [[ $arg =~ ^[0-9.]+[bskmgtp]?$ ]]; then	# it's a size
				size=$arg
		  elif [[ $arg =~ ^[a-z0-9]+$ ]]; then		# its a mapper name
				mapname=$arg
		  else
				ribbit 2 "What the hell is this? $arg"
		  fi
	 done

	 # convert to number of 512 byte blocks - both dd and blockdev use this
	 size=$(fsconv $size 'in' s)

	 # if it's a uuid
	 if [[ "$dev" =~ ^[a-f0-9]{8}(-[a-f0-9]{4}){3}-[a-f0-9]{12}$ ]]; then
		  dev=/dev/disk/by-uuid/$dev
	 fi

	 # make sure it exists
	 until dev_canon=$(readlink -e "$dev"); do
		  # apparently it doesn't. if it was supposed to be a device, screw that
		  [ "${dev:0:4}" = /dev ] && {
				shell_is_interactive || ribbit 2 "edev '$dev' doesn't exist! Check hardware."

				# we can comment it out so the message doesn't bother us again
				askyn "$dev ($name) doesn't exist! Avoid checking in the future?" \
					 && sed -i 's/^:\s*edev\s*.*\s*\('"${dev##*/}"'.*\)$/#\0/ig' /etc/rc.conf
				ribbit 2
		  }
		  # otherwise, we make it
		  echo_red "Encrypted loopback file doesn't exist! Touching it..."
		  am_root || ribbit 2 "Root must fix."
		  local dev_intermediate=$(readlink -m "$dev")
		  mkdir -p "$(dirname "$dev_intermediate")"
		  touch "$dev_intermediate"
		  chmod 600 "$dev_intermediate"
	 done
	 dev=$dev_canon

	 # fewer crypt iterations on low-mem cpus
	 iters=9999
	 mem=$(awk '/^MemTotal:/ {print $2}' /proc/meminfo)
	 [ "$mem" -lt 1048576 ] && iters=999

	 # make sure it's luks formatted
	 until type=$(/sbin/blkid -o value -s TYPE "$dev") && [ "$type" = crypto_LUKS ]; do
		  echo_red "$dev is NOT luks formatted!"
		  am_root || ribbit 2 "Non-root user cannot fix or create the LUKS device"
		  kernel_supports_luks || ribbit 2 "no xts encryption, cannot fix or create"
		  # make sure dev is either empty OR we have permission to override!
		  [ -s "$dev" ] && {
				[ "$type" ] \
					 && echo_red "Encrypted device $edev is formatted as: $type!" \
					 || echo_red "Encrypted device $edev is not in a known block format!"
				shell_is_interactive || ribbit 2 "Will not overwrite anything without your permission..."
				askyn "Skip and preserve data? (Otherwise we'll overwrite it...)" && ribbit 2
		  }

		  # fill w/random data, using given size if it's a file (or all of partition)
		  [ -b $dev ] \
				&& dd_with_progress if=/dev/urandom of="$dev" bs=512 \
				|| dd_with_progress if=/dev/urandom of="$dev" bs=512 count=$size

		  # now format luks, using default key
		  echo -n "loosest slots in town" | \
				cryptsetup -qvi $iters -S 1 -d - -s 512 -c aes-xts-plain64 -h whirlpool luksFormat "$dev"

		  chrooted && {
				echo_red "WE ARE DOING DEV MAPPINGS IN A CHROOT! LOOK FOR ERRORS!"
		  }
		  # as long as mapname is unique here, it should work ok ... i think

		  # open it once, format ext4, then close it
		  echo -n "loosest slots in town" | \
				cryptsetup luksOpen "$dev" ${mapname}tmp -d - \
				|| ribbit 2 "Can't open luks device we just made! Something is fucked."

		  # format ext4
		  . /usr/share/ppz/bash.functions.install
		  format_ext4 automatic /dev/mapper/${mapname}tmp || ribbit 2 "Formatting ext4 failed"

		  if type=$(/sbin/blkid -o value -s TYPE /dev/mapper/${mapname}tmp) \
				&& [ "$type" = ext4 ]; then
				echo "Formatting ext4 was successful"
		  else
				ribbit 2 "Formatting $dev ext4 returned 0 but did not seem to work."
		  fi

		  cryptsetup luksClose ${mapname}tmp
	 done

	 # make sure its not DEFAULT KEY
	 am_root && cryptsetup luksDump "$dev" | grep -qiE '^Key Slot 7: DISABLED$' && {
		  if askyn "Shall we set a new, secure key for $dev ... ?"; then
				cryptsetup -yvi $iters -S 7 -d <(echo -n "loosest slots in town") luksAddKey "$dev"
				echo_red "Please enter the new password again, so we can kill the old one :)"
				cryptsetup luksKillSlot "$dev" 1
		  else
				echo_red "Leaving insecure default key for $dev ..."
		  fi
	 }

	 # make sure size is right
	 [ -b "$dev" ] || { # we dont resize block devices
		  # we know dev is path to a loopback file

		  # $size is number of 512-byte sectors we want it to be.
		  # We subtract from that the number of sectors it ACTUALLY is.
		  sectors_wanting=$(( $size - ( $(stat -c %s $dev) / 512 ) ))

		  [[ "$sectors_wanting" =~ ^[0-9]+$ ]] || ribbit "Reading loop size fucked up."

		  if [ $sectors_wanting -lt 0 ]; then
				ribbit "Must shrink loopback devices manually - good luck..."
		  elif [ $sectors_wanting -eq 0 ]; then
				: #echo "$dev is correct size: $size sectors"
		  else
				# this means we grow the size
				am_root || ribbit "$dev is the wrong size - root must fix!"
				echo "Growing $dev by $sectors_wanting sectors to $size sectors"
				dd if=/dev/urandom bs=512 count=$sectors_wanting >> $dev \
					 || ribbit "dd grow command failed"

				# for each loopback that might exist for $dev
				# will this work in a chroot??
				for loop in $(losetup -j $dev | sed 's%^\(/[^:]*\):.*$%\1%ig;t;d'); do

					 echo_red "Resizing $dev at $loop - if in chroot, take note this worked :D"

					 # make it read new size
					 losetup -c $loop

					 # if mapped, resize that too
					 # running this for each loop is a bug, but for now i'll be lazy
					 # and assume there will always be just one loop :P
					 cryptsetup status $mapname \
						  | grep -iq /dev/mapper/$mapname' is active and is in use.' && {

						  # code to read current map size - probably dont need?
						  #$(blockdev --getsz /dev/mapper/$mapname)

						  # resize mapping
						  cryptsetup resize $mapname

						  # resize filesystem inside mapping - online or offline
						  # if we're running in a chroot, this will (should) also fail
						  ! chrooted && findmnt -n /dev/mapper/$mapname >/dev/null \
								&& mount -o remount,resize /dev/mapper/$mapname \
								|| resize2fs /dev/mapper/$mapname
					 }
				done
		  fi
	 }

	 # we have made sure the luks device exists, is formatted and sized right
	 # if we just formatted luks, we also created the filesystem inside
	 # for root, this is enough.
	 am_root && return

	 # if still here, we are not root.
	 # we are interested it opening up OUR device for use.
	 # openmap gives us privilege to do that.

	 # right now takes usename as argument - maybe $UID is enough? testing.
	 sudo /usr/sbin/openmap $(whoami)
}
integrity_encdevs() { local devcond devline IFS=$'\n'

	 # which devices do we care about? all (if root) or just ours?
	 am_root \
		  && devcond='(1)' \
		  || devcond='($3 == "'$(encdev_from_user)'")'

	 # for devices we care about, make sure they all work
	 for devline in $(awk '/^:/ {
					if (($2 == "edev") && '"$devcond"') print
				}' /etc/rc.conf); do
		  IFS=$'\n\r\t '; integrity_encdev $devline
	 done
}
integrity_tmpdir() {
	 am_root && return
	 export mytmpdir=/tmp/.$EUID.$USER
	 export mytmpln=~/.config/tmpdir
	 [ -a $mytmpdir ] || mkdir $mytmpdir
	 [ -O $mytmpdir ] || {
		  echo_red "$mytmpdir WAS STOLEN??"
		  return
	 }
	 enforce_perms 700 $mytmpdir
	 [ -L $mytmpln ] || ln -s $mytmpdir $mytmpln
	 [ "$(readlink -m $mytmpln)" == $mytmpdir ] || {
		  rm -f $mytmpln
		  ln -s $mytmpdir $mytmpln
	 }
}
integrity_emacsd() {
	 [ -O $HOME ] || return 1

	 local F=~/.emacs.d
	 [ -L ${F} ] || {
		  [ -d ${F} ] && mv ${F} ${F}.$(uniq_token)
		  [ -a ${F} ] && echo "weird ${F}!" || ln -s /etc/.emacs.d ~/
	 }
	 am_root && {
		  enforce_perms 444 /etc/.emacs.d/init.el
		  enforce_perms 555 /etc/.emacs.d
	 }
	 return 0
}
integrity_bashhistory() { local hf hfs attrset skel_file backup_file
	 set_proper_histfile

	 # which files will we check and/or fix?
	 am_root && hfs=($(awk -F : '{
		  if ($6 ~ /\/(home|media|root)/) print $6 "/.bash_history"
	 }' /etc/passwd)) || hfs=(${HISTFILE:-$HOME/.bash_history})

	 for hf in "${hfs[@]}"; do

		  [ -d "${hf%/*}" ] || continue

		  # if the file is append-only, leave it be (and report)
		  # for non-priv user, we couldnt do anything else if we tried!
		  attrset=$(lsattr "$hf" 2>/dev/null) \
				&& [ "${attrset:5:1}" = a ] && continue

		  # now for the ridiculous logic of enforcing the skel prefix!
		  # this could probably make more sense if i thought about it...
		  skel_file=/etc/skel.ppz/.bash_history
		  if ! [ -s "$hf" ]; then
				# file is empty, no-brainer. just fill with skel file.
				echo_red "$hf is empty - filling it from skel"
				cat ${skel_file} >> ${hf}
		  elif cmp -s <(head -n 1 ${hf}) <(head -n 1 ${skel_file}); then
				: #first lines match. peachy.
		  elif askyn "$hf ("$(du -sh ${hf} | cut -f 1)") has no skel prefix. Join them?"; then
				# user has consented to the replacement algorithm
				backup_file=${hf}.ppz.$(date +%s)
				mv ${hf} ${backup_file}
				cp ${skel_file} ${hf}
				cat ${backup_file} >> ${hf}
				cmp -s <(cat ${skel_file} ${backup_file} | md5sum) <(cat ${hf} | md5sum) \
					 && rm ${backup_file} \
					 || echo_red "Delete ${backup_file} yourself, I wasn't sure..."
		  fi

		  am_root && [ ${hf:0:5} != /tmp/ ] && {
				echo_red "Marking $hf append-only."
				say_and_do chattr +a "$hf"
		  }
	 done; :
}
integrity_sshd() {
	 am_root || return 0
	 local OLDFILE=/etc/ssh/sshd_config
	 local NEWFILE=${OLDFILE}.$(uniq_token)
	 cat > ${NEWFILE} <<-EOF
		ListenAddress 0.0.0.0
		Protocol 2
		LoginGraceTime 2m
		PermitRootLogin no
		#MaxAuthTries 6
		#MaxSessions 10
		#PasswordAuthentication yes
		ChallengeResponseAuthentication no
		UsePAM yes
		X11Forwarding no
		#X11DisplayOffset 10
		PrintMotd no
		PrintLastLog no
		#UseLogin no
		#MaxStartups 10
		#PermitTunnel no
		IgnoreRhosts yes
		HostBasedAuthentication no
		PermitEmptyPasswords no
		AuthorizedKeysFile .ssh/authorized_keys
		Subsystem	sftp	internal-sftp

		AllowUsers
		EOF
	 for USER in ${SSH_USERS[@]}; do
		  case "${USER:0:1}" in
				\!|@)	local BAREUSER=${USER:1};;
				*)		local BAREUSER=${USER};;
		  esac
		  local USER_ALLOWED=yes
		  [ ${USER:0:1} = \! ] && USER_ALLOWED=no
		  [ ${BAREUSER} = root ] && \
				sed -i 's/^#*\(PermitRootLogin\).*$/\1 '${USER_ALLOWED}'/gi' ${NEWFILE}
		  [ ${USER_ALLOWED} = yes ] && sed -i 's/^#*\(AllowUsers\(\s[a-zA-Z]*\)*\)$/\1 '${BAREUSER}'/gi' ${NEWFILE}
		  [ ${USER:0:1} = @ ] && cat >> ${NEWFILE} <<-EOF

			Match User ${BAREUSER}
			   ChrootDirectory /home/wall/${BAREUSER}
			   X11Forwarding no
			   AllowTcpForwarding no
			   ForceCommand internal-sftp
			EOF
	 done
#	 ALL OF THIS is such a stinking mess! when fix???
#	 askyn "did you inspect?"
	 if conffile_checkup "${OLDFILE}" "${NEWFILE}"; then
		  #file changed
		  chrooted || {
				# not chrooted
				echo_red pkilling sshd
				pkill -HUP -f /usr/sbin/sshd; SSHD_ON=$?
		  }
	 else
		  #file didnt change
		  [ -n "$(pgrep -f /usr/sbin/sshd)" ]; SSHD_ON=$?
	 fi
	 ifn $SSHD_ON || {
		  askyn "sshd is not running. Start it?" && {
				/etc/rc.d/sshd start
		  } || echo_red "did not start sshd"
	 }
}
integrity_sensors() {
	 pacman -Qq lm_sensors &>/dev/null || return 0
	 local sc=/etc/conf.d/lm_sensors
	 [ -s $sc ] && return
	 echo_red "Missing $sc"
	 am_root || return 0
	 askyn "Auto-generate $sc ?" || {
		  echo_red ok, do it yourself
		  return
	 }
	 yes "" | /usr/sbin/sensors-detect
	 echo_blue "Remember, add DAEMONS=(sensors) or MODULES=(...)"
}

# this gets run in:
#   post_install
#    functions.d
#     ppz/bash.rc
#      post_upgrade

for F in rootpw locales tz simpleconf inittab hosts users \
	 iptables net encdevs bashhistory emacsd tmpdir sshd \
	 sensors; do

	 integrity_${F} || echo "${F} failed..."
done
