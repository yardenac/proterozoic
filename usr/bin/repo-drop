#!/usr/bin/bash
# 
# make Arch repos easier & more versatile

# should really handle rsync ssh lines, not need sshfs

# Use local functions if possible (for `./package-this`)
funcspath=usr/share/ppz/bash.functions
if [ -s $funcspath ]; then
	 . $funcspath
elif [ -s /$funcspath ]; then
	 . /$funcspath
else
	 echo "No functions file!"
	 exit 1
fi

# config sets bash array $rd_args
configfile=~/.config/repo-drop
if [ -s $configfile ]; then
	 . $configfile
fi

shopt -s nullglob

dirs=()
packs=()
for arg in "$@" "${rd_args[@]}"; do
	 item=$(full_path_strict "$arg") || ribbit "SKIPPING NON-EXISTENT ITEM: $arg"
	 if [ -d "$item" ]; then
		  dirs+=("${item%/}")
	 elif is pkg "$item"; then
		  packs+=($item)
	 else
		  echo_red "SKIPPING WEIRD ARG: $item"
	 fi
done

(( ${#dirs[@]} )) && (( ${#packs[@]} )) || \
	 croak "USAGE: repo-drop /path/to/repo/ to-add.pkg.tar.xz"

for pack in "${packs[@]}"; do

	 echo_green_n "DOING PACKAGE: $pack "
	 pack_base=$(basename "$pack")
	 pack_dir=$(dirname "$pack")

	 arch=$(bsdtar -xOf "$pack" .PKGINFO | awk '/^arch =/ {print $3}')

	 [ -f "$pack.sig" ] || {
		  echo
		  if askyn "$pack: No signature found. Sign it?"; then
				gpg --detach-sign --use-agent "$pack"
		  fi
	 }
	 if [ -f "$pack.sig" ]; then
		  if gpg --verify "$pack.sig" </dev/null &>/dev/null; then
				echo_green "[VALID SIGNATURE]"
		  else
				echo_red "[INVALID SIGNATURE - SKIPPING!]"
				continue
		  fi
	 fi

	 oldfiles=()
	 newfiles=()
	 for dir in "${dirs[@]}"; do

		  case $arch in
				'i686'|'x86_64') dbs=("$dir"{,/$arch}/*.db.tar.gz);;
				'any') dbs=("$dir"{,/{i686,x86_64}}/*.db.tar.gz);;
				*) echo_red "SKIPPING PKG WITH UNKNOWN ARCHITECTURE: $arch"; continue 2;;
		  esac

		  (( ${#dbs[@]} )) || echo_red "NO VALID DBs for $arch in $dir"

		  for db in "${dbs[@]}"; do
				is db "$db" || continue
				repo=$(dirname "$db")
				if [ -a "$repo/$pack_base" ]; then
					 askyn "$repo/$pack_base  <-- ALREADY EXISTS. REPLACE?" || {
						  echo_red "NOT ADDING, ALREADY EXISTS: $repo/$pack_base"
						  newfiles+=("$repo/$pack_base")
						  continue
					 }
				fi
				oldfiles+=("$repo/${pack_base%-*-*-*.pkg.tar.?z}"-*-*-*.pkg.tar.?z)

				uplist=("$pack_base")
				if [ -f "$pack_base.sig" ]; then
					 uplist+=("$pack_base.sig")
				else
					 oldfiles+=("$repo/$pack_base.sig")
				fi
				for upfile in "${uplist[@]}"; do
					 rsync --out-format='%t %o %f' --inplace -LPhz -e 'ssh -C' "$pack_dir/$upfile" "$repo/$upfile"
				done

				repo-add "$db" "$repo/$pack_base"
		  done
	 done

	 to_del=()
	 for oldfile in "${oldfiles[@]}"; do
		  for newfile in "${newfiles[@]}"; do
				[ "$oldfile" = "$newfile" ] || to_del+=("$oldfile")
		  done
	 done

	 (( ${#to_del[@]} )) && {
		  ls -lF "${to_del[@]}"
		  askyn "Delete older pkgs on server?" && rm -f "${to_del[@]}"
	 }
	 askyn "Delete original pkg?" && rm -vf "$pack"{,.sig}
done
