#!/bin/bash
# 
# a little bit less tedious than remembering long file paths!

# make this check pkginfo and automatically figure out $arch
# should find file with bash-completion!
# should really handle rsync ssh lines, not need sshfs
# with all that, it should be as easy as "repo-drop [tab] [enter]"

# Use local functions if possible (for `./package-this`)
funcspath=usr/share/ppz/bash.functions
if [ -s $funcspath ]; then
	 . $funcspath
elif [ -s /$funcspath ]; then
	 . /$funcspath
else
	 echo "No functions file!"
	 exit 1
fi

# config sets bash array $rd_args
configfile=~/.config/repo-drop
if [ -s $configfile ]; then
	 . $configfile
fi

shopt -s nullglob

dbs=()
packs=()
for arg in "$@" "${rd_args[@]}"; do
	 item=$(full_path_strict "$arg") || ribbit "SKIPPING NON-EXISTENT ITEM: $arg"
	 if [ -d "$item" ]; then
		  item=${item%/}
		  for db in "$item"/*.db.tar.gz; do
				is db "$db" && {
					 dbs+=("$db")
					 continue 2
				}
		  done
		  echo_red "SKIPPING DIR W/O DB: $item"
	 elif is pkg "$item"; then
		  packs+=($item)
	 else
		  echo_red "SKIPPING WEIRD ARG: $item"
	 fi
done

(( ${#dbs[@]} )) && (( ${#packs[@]} )) || \
	 croak "USAGE: repo-drop /path/to/repo/ to-add.pkg.tar.xz"

for pack in "${packs[@]}"; do

	 echo_green "DOING PACKAGE: $pack"
	 pack_base=$(basename "$pack")
	 to_del=()
	 for db in "${dbs[@]}"; do
		  repo=$(dirname "$db")
		  [ -a "$repo/$pack_base" ] && {
				echo_red "NOT ADDING, ALREADY EXISTS: $repo/$pack_base"
				continue
		  }
		  to_del+=("$repo/${pack_base%-*-*-*.pkg.tar.?z}"-*-*-*.pkg.tar.?z)
		  rsync --out-format='%t %o %f' --inplace -LPhz -e 'ssh -C' "$pack" "$repo/$pack_base"
		  repo-add "$db" "$repo/$pack_base"
	 done

	 (( ${#to_del[@]} )) && {

		  ls -lF "${to_del[@]}"

		  askyn "Delete older pkgs on server?" && rm -f "${to_del[@]}"
	 }

	 askyn "Delete original pkg?" && rm -f "$pack"
done
