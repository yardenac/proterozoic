#!/usr/bin/bash

# Check an arch repository for AUR updates

export cower='cower --timeout=60'

vergt () {
    [ "$1" = "$2" ] && return 1
    [ "$(vercmp "$1" "$2")" -gt 0 ]
}
is_pkg() {
    local type
    type=$(file -ib "$1") || return 1
    case "${type%%;*}" in
        application/x-xz|application/x-gzip) return 0;;
        *) return 1
    esac
    return 0
}
show_if_diff_hash() {
    name=$1; vhere=$2; vthere=$3; hash=$4; url=$5
    [ "$hash" ] || return
    [[ "$vhere" =~ "$hash" ]] && return
    echo_blue_n "$name $vhere "
    echo_cyan_n "$vthere $hash"
    echo " $url"
}
show_github() {
    local commit date hash vers_github vers_here url
    vers_here=$1
    url=$2
    url="${url##*::}"
    url="${url##git+}"
    url="${url%%.git}"
    commit=$(curl -s "$(echo "$url" | sed 's_^https\?://github.com/_https://api.github.com/repos/_; t; d')"/commits | jshon -e 0)
    date=$(echo "$commit" | jshon -e commit -e author -e date | tr -d \")
    hash=$(echo "$commit" | jshon -e sha | tr -d \" | colrm 8)
    vers_github=$(date -d "$date" "+%Y%m%d-1")
    show_if_diff_hash "$name" "$vers_here" "$vers_github" "$hash" "$url/commits/master"
}
ck_pkg() {
    local base file giturl hash ig_pkgn name pkgdeets url vers_here vers_there
    file=$(readlink -e "$1") || return 1
    is_pkg "$file" || return 1
    pkgdeets=($(tar -xOf "$file" .PKGINFO 2>/dev/null | awk '/^pkg(name|ver) *=/ {print $3}')) || return 1
    (( "${#pkgdeets[@]}" )) || return 1
    name=${pkgdeets[0]}
    for ig_pkgn in "${ignore_pkgnames[@]}"; do
        [ "x$name" = "x$ig_pkgn" ] && return
    done
    vers_here=${pkgdeets[1]}
    vers_there=$($cower --info --format="%v" "${name}") || {
        echo_red "package not in AUR: $name"
        return 1
    }
    base=$($cower --info --format="%b" "${name}")
    flagged=$($cower --info --format="%t" "${name}")
    [ "$flagged" = no ] && [ "$vers_here" = "$vers_there" ] && {
        [[ $verbose == y ]] && echo_blue "$name $vers_here "
        return
    }
    if vergt "$vers_here" "$vers_there"; then
        if [ "$vers_here" = "$vers_there.${vers_here##*.}" ]; then
            [[ $verbose == y ]] && \
                echo_blue_n "$name $vers_here " && \
                echo_green "INCREMENTAL"
            return
        fi
        url=$($cower --info --format="%u" "${name}")
        if [[ "$url" =~ github.com ]]; then
            show_github "$vers_here" "$url"
        else
            hash=''
            if cower --quiet --force --timeout=60 --ignorerepo -d "${name}" >/dev/null; then
                giturl=$(awk '($1 ~ /source/ && $3 ~ /^([a-zA-Z0-9-]+::)?git/) {print $3; exit}' "${base}"/.SRCINFO)
                if ! [ "${giturl}" ]; then
                    :
                elif [[ "$giturl" =~ github.com ]]; then
                    show_github "$vers_here" "$giturl"
                    return
                else
                    url="${giturl##*::}"
                    url="${url##git+}"
                    hash=$(git ls-remote --heads "$url" master 2>/dev/null | awk '($2 = "refs/heads/master") {print $1}')
                    hash=${hash:0:7}
                fi
            fi
            show_if_diff_hash "$name" "$vers_here" "$vers_there" "$hash" "$url"
        fi
    elif [ "$vers_here" != "$vers_there" ]; then
        echo_blue_n "$name $vers_here "
        echo_yellow "$vers_there"
    elif [ "$flagged" = yes ]; then
        echo_blue_n "$name $vers_here "
        echo_cyan_n "$vers_there "
        echo_yellow "FLAGGED"
    else
        echo_red "WEIRD THING HAPPENED"
    fi
}
is_repo() {
    [ -d "$1" ] || return 1
    local item=${1%/}
    is db "$item"/*.db.tar.gz && return 0
    return 1
}
ck_repo() {
    local file
    [ "$print_repos" ] && echo_green "$1"
    find -P "$1" -xdev -maxdepth 1 -ignore_readdir_race -type f | sort | while read file; do
        ck_pkg "$file"
    done
}

. /usr/share/ppz/bash.functions
wehave jshon || return 1

shopt -s nullglob

repos=() pkgs=()
verbose='' loop=''
conf=~/.config/ckrepo
[ -f "$conf" ] && . "$conf"
for arg; do
    case "$arg" in
        -v|--verbose) verbose=y; continue;;
        -l|--loop)    loop=y;    continue;;
    esac
    if item=$(full_path_strict "$arg"); then
        if is_repo "$item"; then
            repos+=("$item")
        elif is_pkg "$item"; then
            pkgs+=("$item")
            loop=''
            repos=()
        else
            echo_red "Not a repo or pkg: $item"
        fi
    else
        echo_red "Unknown option: $item"
    fi
done

(( ${#repos[@]} )) || {
    is_repo ./ && repos+=(./)
}

(( ${#repos[@]} + ${#pkgs[@]} )) || croak "USAGE: ckrepo repo/ [repo/]"

print_repos=''
[ ${#repos[@]} -gt 1 ] || [ "$verbose" ] && print_repos=y

tmpdir=/tmp/ckrepo.$(uniq_token)
ckr_cleanup() { popd &>/dev/null; rm -rf "$tmpdir"; }
trap "ckr_cleanup; exit;" EXIT HUP QUIT INT TERM ABRT TSTP CONT
mkdir "$tmpdir"
pushd "$tmpdir" >/dev/null

loop() {
    while :; do
        [ "$loop" ] && echo_green $(date)
        for repo in "${repos[@]}"; do
            ck_repo "$repo"
        done
        for pkg in "${pkgs[@]}"; do
            ck_pkg "$pkg"
        done
        rm -rf "$tmpdir"/*
        [ "$loop" ] || break
        sleep 1h
        echo; echo
    done
    exit
}
loop
